# -*- coding: utf-8 -*-
"""Cataract_vgg16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/160k1UxCuGrZHikl14bYtFvej03KYAyyS
"""

import os
import numpy as np
import pandas as pd
import keras

!pip install scipy==1.1.0

from google.colab import drive
drive.mount('/content/gdrive')

os.chdir("/content/gdrive/My Drive/Colab Notebooks")
os.getcwd()

import os, csv

with open("/content/gdrive/My Drive/Colab Notebooks/Train.csv", 'w') as f:
    writer = csv.writer(f)
    for path, dirs, files in os.walk("/content/gdrive/My Drive/Colab Notebooks/Train"):
        for filename in files:
            if (filename[0:2]=="ca"):
              writer.writerow([filename,"C"])
            else:
              writer.writerow([filename,"NC"])

import os, csv

with open("/content/gdrive/My Drive/Colab Notebooks/Test.csv", 'w') as f:
    writer = csv.writer(f)
    for path, dirs, files in os.walk("/content/gdrive/My Drive/Colab Notebooks/Test"):
        for filename in files:
            if filename[0:2]=="ca":
              writer.writerow([filename,"C"])
            else:
               writer.writerow([filename,"NC"])

colnames=['filename','label']
train=pd.read_csv("/content/gdrive/My Drive/Colab Notebooks/Train.csv",names=colnames)
test=pd.read_csv("/content/gdrive/My Drive/Colab Notebooks/Test.csv",names=colnames)
print (train)
print(test)

from keras.models import Sequential
from scipy.misc import imread
get_ipython().magic('matplotlib inline')
import matplotlib.pyplot as plt
import numpy as np
import keras
from keras.layers import Dense
import pandas as pd

from keras.applications.vgg16 import VGG16
from keras.preprocessing import image
from keras.applications.vgg16 import preprocess_input
import numpy as np
from keras.applications.vgg16 import decode_predictions
from keras.utils.np_utils import to_categorical

from sklearn.preprocessing import LabelEncoder
from keras.models import Sequential
from keras.optimizers import SGD
from keras.layers import Input, Dense, Convolution2D, MaxPooling2D, AveragePooling2D, ZeroPadding2D, Dropout, Flatten, merge, Reshape, Activation

from sklearn.metrics import log_loss

train_path="/content/gdrive/My Drive/Colab Notebooks/Train"
test_path="/content/gdrive/My Drive/Colab Notebooks/Test"

from scipy.misc import imresize


train_img=[]
for i in range(len(train)):

    temp_img=image.load_img(train_path+'/'+train['filename'][i],target_size=(224,224))

    temp_img=image.img_to_array(temp_img)

    train_img.append(temp_img)



train_img=np.array(train_img)
train_img=preprocess_input(train_img)


test_img=[]
for i in range(len(test)):

    temp_img=image.load_img(test_path+'/'+test['filename'][i],target_size=(224,224))

    temp_img=image.img_to_array(temp_img)

    test_img.append(temp_img)

test_img=np.array(test_img)
test_img=preprocess_input(test_img)


from keras.models import Model

def vgg16_model(img_rows, img_cols, channel=1, num_classes=None):

    model = VGG16(weights='imagenet', include_top=True)

    model.layers.pop()

    model.outputs = [model.layers[-1].output]

    model.layers[-1].outbound_nodes = []

    x=Dense(num_classes, activation='softmax')(model.output)

    model=Model(model.input,x)


    for layer in model.layers[:8]:
       layer.trainable = False

    sgd = SGD(lr=1e-3, decay=1e-6, momentum=0.9, nesterov=True)
    model.compile(optimizer=sgd, loss='categorical_crossentropy', metrics=['accuracy'])

    return model

train_y=np.asarray(train['label'])

le = LabelEncoder()

train_y = le.fit_transform(train_y)

train_y=to_categorical(train_y)

train_y=np.array(train_y)





from sklearn.model_selection import train_test_split
X_train, X_valid, Y_train, Y_valid=train_test_split(train_img,train_y,test_size=0.1, random_state=42)


img_rows, img_cols = 224, 224 
channel = 3
num_classes = 2
batch_size = 20
epoch = 10


model = vgg16_model(img_rows, img_cols, channel, num_classes)

model.summary()

model.fit(X_train, Y_train,batch_size=batch_size,epochs=epoch,shuffle=True,verbose=1,validation_data=(X_valid, Y_valid))


predictions_valid = model.predict(X_valid, batch_size=batch_size, verbose=1)


score = log_loss(Y_valid, predictions_valid)

print(score)

